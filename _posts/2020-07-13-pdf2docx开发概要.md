---
layout: post
author: Train
description: pdf2docx开发思路与备忘
keywords: pdf2docx pdf-converter
tags: [python]
---

**PDF转Word**是一个老话题，其难点在于建立PDF基于元素位置的格式与Word基于内容的格式之间的映射关系。[`Solid Documents`](https://solidframework.net/)是这方面的佼佼者，其技术的应用案例：在线PDF转换网站[Smallpdf](https://smallpdf.com/pdf-to-word)。

在某个项目的调研过程中，作者从开源技术的角度尝试了这个话题，写了一个用于PDF转换Word的Python库`pdf2docx`，依赖`PyMuPDF`解析PDF文件，并用`python-docx`创建Word文件。本文记录相关开发思路。

项目地址：[https://github.com/dothinking/pdf2docx](https://github.com/dothinking/pdf2docx)


## 基本思路

- PDF文件遵循一定的格式规范[[^1]]，Python库[`PyMuPDF`](https://github.com/pymupdf/PyMuPDF)提供了便利的解析函数，用于获取页面元素例如文本和形状及其位置。

- 利用元素间的相对位置关系推断内容，例如将“横纵线条围绕着文本”解析为“表格”，将“文本下方的一条横线”解析为“文本下划线”。这就是本文主角`pdf2docx`的主要内容。

- 使用Python库`python-docx`将上一步解析的内容元素重建为docx格式的Word文档。

以上技术路线也决定了`pdf2docx`的局限：

- 根据有限的、确定的规则建立PDF导出元素位置与docx要求的内容之间的映射并非完全可靠，也就是说仅能处理常见的规范的格式，而非百分百还原。

- Word格式还受到`python-docx`处理能力的限制，例如截至版本`0.8.10`，`python-docx`尚不支持浮动图片。

## 出发点

文本、图片及矩形涵盖了大部分常见的PDF元素，这些是`pdf2docx`的处理基础。

### 文本与图片

`PyMuPDF`的`Textpage`对象提供的`extractDICT()`和`extractRAWDICT()`用以获取页面中的所有文本和图片（内容、位置、属性），基本数据结构如下[[^2]]：

![文本与图片块结构](https://pymupdf.readthedocs.io/en/latest/_images/img-textpage.png)

`pdf2docx`继续沿用以上数据结构，但图片块将被进一步整合到文本块中，作为`line`>`span`级别的元素。

### 矩形

PDF规范定义了各种路径及其围成的图形，`pdf2docx`仅仅处理水平或竖直方向的矩形，例如代表文本高亮的矩形块，或者表格边线的直线（很细的矩形）。可惜`PyMuPDF`没有提供或者这些元素的API，只能自行从原始的页面内容中解析，参考厚厚的PDF规范[[^1]]。

```python
pdf = fitz.open(file_path)
for page in pdf:
    for xref in page._getContents():
        page_content = pdf._getXrefStream(xref).decode(encoding="ISO-8859-1")

# 输出示例
/P<</MCID 0>> BDC
...
1 0 0 1 90.0240021 590.380005 cm
...
1 1 0 rg # or 0 g
...
285.17 500.11 193.97 13.44 re f*
...
214 320 m
249 322 l
...
EMC
```

- `cm`：坐标变换，本例(0,0)平移至(90.0240021 590.380005)
- `q`/`Q`：保存/调出画笔
- `rg`/`g`：指定颜色模式：RGB/灰度
- `re`, `f` or `f*`: 使用预定颜色填充矩形路径。如果没有`f`/`f*`，则仅仅是矩形路径而不进行填充。本例中，
    - 填充黄色 (1,1,0)
    - 矩形左下角: (285.17 500.11)
    - 宽度: 193.97 Pt
    - 高度: 13.44 Pt
- `m`, `l`: 从`m`向`l`画直线路径；后续可以继续`l`，表示多边形路径。

此外，在PDF文件基础上进行的批注操作例如高亮、下划线，可以直接使用`Page`对象的`annots()`方法获取，其中的`type`属性表明了该批注的类型[[^3]]。例如，`pdf2docx`关心的有：

```python
PDF_ANNOT_HIGHLIGHT 8
PDF_ANNOT_UNDERLINE 9
PDF_ANNOT_STRIKEOUT 11
```

综合以上，矩形元素（原始矩形、原始直线及批注矩形和直线）将被定义如下数据结构：

```python
{
    'type': int,
    'bbox': (x0, y0, x1, y1),
    'color': int  # e.g. 16711680
}
```

其中, 类型代码：

- not defined   : -1
- highlight     : 0
- underline     : 1
- strike-through: 2
- table border  : 10
- cell shading  : 11


## 表格解析与重建

参考文本和图片，定义表格类型的数据结构：

```python
{
    'type': int, # 3-explicit table; 4-implicit table
    'bbox': (float, float, float, float),
    'cells': [
        {
            'bbox': (float, float, float, float),
            'bg-color':  int,
            'border-color': (int, int, int, int), # top, right, bootom, left
            'border-width': (float, float, float, float),
            'merged-cells': (int, int),
            'blocks': [
                {
                    # text/image blocks contained in current cell
                }
            ]
        }
    ]
}
```

### 显式表格：有边线

从边线出发，确定表格结构->单元格属性->单元格内容：

- 以是否相交为依据分组矩形元素，每一组即为潜在的表格区域，每一个矩形可能是边框线（table border）、单元格背景（cell shading）或者文本样式（highlight/underline/strike-through）。

- 基于边框线类型的矩形确定表格结构

    - 每一组内，以**至少相交一次**和**较细**为依据筛选出可能的边框线。

    - 判断是否存在外边框线，没有则加上假想的外边框线（白色、宽度0）。

    - 将边框线按横、纵分组得到行间隔线和列间隔线，横纵间隔线的交点组成了初始的未考虑合并单元格的表格结构。

    - 对于每一行，检测一条假想水平线与列边线的交点：不存在交点的位置即发生了行方向的合并单元格；同理检测列方向的合并单元格。

- 基于表格结构确定单元格属性

    - 以左上角单元格表示合并单元格区域，被合并的单元格设为None。
    
    - 根据每一个单元格的区域（合并单元格则考虑所有合并区域）确定边框的四个矩形：从而直接得到各个边框的宽度和颜色；并根据单元格区域检测cell shading类型的矩形，存在则得到单元格背景色。

- 基于表格结构确定单元格包含的文本

    - 将包含于单元格区域的文本/图片加入到相应单元格。有时文本块的划分与单元格区域并不严格匹配，需要深入到`block`>`line`>`span`>`char`级别拆分原始文本块。

    - 将单元格内的图片块转为文本块。

    - 如果两个文本块物理上处于同一行，则合并为一个大文本块。目的是创建Word文档时保证正确的位置关系，因为每一个文本块将被作为独立的段落。


得到表格的位置及属性后，需要考虑能否在`python-docx`中重建。好在或者直接使用API或者借助`openxml`，以下操作都被`python-docx`支持：

- 表格缩进 [[^4]]
- 合并单元格 `cell.merge(other_cell)` [[^5]]
- 行高`row.height`及单元格宽度`cell.width` [[^5]]
- 单元格内边距 [[^6]]
- 单元格边框颜色和宽度 [[^7]]
- 单元格背景色 [[^8]]

### 隐式表格：无边线

实际上很难完美重建语义上的无边线表格，`pdf2docx`退而求其次，只是为了保证位置关系，从“看起来一样”的角度解析隐式表格。基本思路：从文本块出发，确定分隔线即边线，解析来与显式表格的处理步骤一致。

- 基于文本块位置关系检测潜在的隐式表格区域

    - 如果同一文本块内`line`级别元素竖直方向有重叠但物理上不是严格处于同一行，它将被视为表格的行。因为docx重建时，普通段落无法保证这样的位置关系，所以必须加入潜在表格区域，后续进一步划分为不同列。

    - 如果同一文本块内`line`级别元素出现多次且相邻之间间隔一定距离，各个`line`将被视为潜在的单元格，因此整个文本块被加入潜在表格区域。

    - 同理，如果相邻两个文本块物理上处于同一行（竖直方向有重叠），它们也将被视为表格区域。

- 基于以上文本块的`line`级别的元素递归检测边界线

    - 按列分组，相邻两组的中间线即为列边界。因为列的角度有利于docx重建，行方向会因为不同文本块另起一段而破坏位置关系。

    - 每一组内按行分组，相邻两组的中间线即为行边界。

    - 重复以上步骤，直到每组只有单一文本块。

如上得到隐式表格区域的假想边框线，接下来按照显式表格流程处理即可。


### 半显式半隐式表格：部分边线

TODO


## 文本样式识别与重建

默认文本块自带了字体、颜色、斜体、粗体等属性，但是高亮、下划线、删除线需要根据文本和矩形的位置关系来判定。在原始文本块数据结构的基础上，为`span`块新增`style`属性：

```python
# dict of span
{
    "bbox": (float, float, float, float)
    "size": float,
    "flags": int,
    "font": str,
    "color": int,
    "text": str, # joined from chars
    "chars": [{...}]
    # ----- new items -----
    "style": [
        {
            "type": int, # 0-highlight, 1-underline, 2-strike-through-line
            "color": int
        }, 
        {...}
    ]            
}
```

高亮、下划线、删除线等属性的确定流程：

- 如果文本块和矩形相交，深入到`line`>`span`级别，得到矩形在`span`上的作用区域

- 利用位置关系判断该`span`的属性：

    - 矩形足够宽 -> 高亮，且根据矩形填充色确定高亮背景色
    - 矩形较细且位于文本中部 -> 删除线
    - 矩形较细且位于文本底部 -> 下划线


以上文本属性都可以直接通过`python-docx`提供的字体相关的API重建[[^9]]。


## 页面布局

经过以上处理，得到了整合后的文本/图片/表格块。其中文本/图片块将被重建为段落，表格块将被重建为表格，其中单元格内文本/图片块按照相同的逻辑处理。

### 页面大小与页边距

`PyMuPDF`解析结果直接包括了页面宽度和高度，同时根据所有块级元素占据区域的极限值得到页边距，例如最小左上角点确定了左边距和上边距。

`python-docx`中页面`section`对象恰好提供了这六个属性，例如`page_width`、`left_margin`。于是页面基本形式得以确定。

### 竖直方向定位

块级元素之间通过段前/段后间距确定相对位置关系，同时保证自身的高度，例如段落行高对于文本块，表格行高对于表格块。由于Word中段落具有段前/段后间距属性，文本块将被作为定位的参考元素。在标准数据结构的基础上，加入如下定位相关属性：

```python
# text block
{
    "type": 0,
    "bbox": [float, float, float, float],
    "lines": [...],
    # ----- new items -----
    "before_space": float,
    "line_space": float,
    "after_space": float
},
```

竖直间距确定原则：

 - 考察竖直方向上相邻的两个块级元素，前一个是参考块，后一个是当前块。对于第一个块级元素，参考块是上边距，当前块即为自身。

 - 如果当前是文本块或者图片块（不论参考块是文本、图片还是表格），则设置当前块的段前间距`before_space`为二者之间垂直距离。同时，
     - 如果当前是文本块，则设置行高`line_space`为平均磅数：文本块高度除以物理行数
     - 如果当前是图片块，则无需显式设置行高，docx创建时直接设置1.05倍行距即可。

 - 否则，如果参考块是文本块或者图片块（此时当前块为表格），则设置段后距离`after_space`

 注意以上并未考虑相邻两个表格的情况，因为尚不知如何直接设置两个表格的间距，权且假定此种情况很少出现吧。后续如果遇到此类需求，可以考虑方案：在间距中插入空行文本块，从而转换为考虑之中的情况。

 
### 水平方向定位

水平方向的定位相对简单些，文本块参考左边距，表格内文本块参考单元格左边界计算出距离，然后设置**制表位**即可。

```python
pf = p.paragraph_format
pf.tab_stops.add_tab_stop(pos)
p.add_run().add_tab()
```


---

[^1]: [1] [PDF Reference 1.7](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdf_reference_archive/pdf_reference_1-7.pdf)
[^2]: [2] [TextPage](https://pymupdf.readthedocs.io/en/latest/textpage.html)
[^3]: [3] [Annotation Types](https://pymupdf.readthedocs.io/en/latest/vars.html#annotation-types)
[^4]: [4] [Using Python's docx library, how can a table be indented?](https://stackoverflow.com/questions/50556604/using-pythons-docx-library-how-can-a-table-be-indented)
[^5]: [5] [Table objects](https://python-docx.readthedocs.io/en/latest/api/table.html#cell-objects)
[^6]: [6] [How to set cell margins of tables in ms word using python docx](https://stackoverflow.com/questions/51060431/how-to-set-cell-margins-of-tables-in-ms-word-using-python-docx)
[^7]: [7] [How to setup cell borders with python-docx](https://stackoverflow.com/questions/33069697/how-to-setup-cell-borders-with-python-docx)
[^8]: [8] [python docx set table cell background and text color](https://stackoverflow.com/questions/26752856/python-docx-set-table-cell-background-and-text-color)
[^9]: [9] [docx.text.run.Font](https://python-docx.readthedocs.io/en/latest/api/text.html#docx.text.run.Font)