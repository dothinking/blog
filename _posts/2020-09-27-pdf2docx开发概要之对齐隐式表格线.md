---
layout: post
author: Train
description: 对齐表格线简化表格结构
keywords: pdf2docx pdf-converter stream-table
tags: [python]
---

[pdf2docx开发概要]({{ site.baseurl }}{% post_url 2020-07-13-pdf2docx开发概要 %})记录了隐式表格`Stream Table`的解析方式：根据文本块位置生成潜在的表格边线，然后采用与显式表格相同的处理方式解析这些边线，得到表格结构。其中，有两个遗留问题：

- 第一步假想表格线时，尽量对齐横纵边线以简化表格结构
- 兼容半隐式表格例如三线表

本文记录这两个问题的处理方案。

## 问题与简化模型

根据下图中绿色块表示的文本位置，我们已经识别出了潜在的表格区域；根据相邻块正中间插入分隔线的原则，得到了图示浅色线表示的表格结构。从显示上来说没有任何问题，因为这些边框线对于隐式表格都是隐藏的。

<div align='center'><img src="{{ "/images/2020-09-27-01.png" | prepend: site.baseurl }}"></div>

需要改进的地方是，从第二行开始，两列的分隔线可以对齐合并，这样使表格结构从`6x6`简化成`6x3`。

<div align='center'><img src="{{ "/images/2020-09-27-02.png" | prepend: site.baseurl }}"></div>

单独看一条竖直边线，它实际上可以在相邻的两个文本块之间活动；我们希望尽可能多的竖直边线通过同一`x`方向位置。于是这个问题简化为：

已知一系列的区间`[x1_s,x1_e], [x2_s,x2_e], ...`，确定尽可能少的垂线`x1,x2,...`，使得每个区间至少有一条线穿过。

下面不妨初始化区间为：

```python
inputs = [[8, 10], [2, 6], [4, 6], [1, 6], [4, 6], [5, 6]]
```

## 求解

```python


class Interval:
    def __init__(self, x_range:tuple=None):
        # valid range
        if x_range: x0, x1 = x_range
        else: x0, x1 = -9999, 9999
        self.LRange, self.URange = x0, x1

        # whether the position is determined        
        self._x = None
        self.finalized = False

    @property
    def x(self): return self._x if self.finalized else (self.LRange+self.URange)/2.0
    
    def is_valid(self, x):
        '''Whether the given position `x` locates in the valid instance range.'''
        return self.LRange < x < self.URange
    
    def finalize(self, x):
        '''Finalize with given position.'''
        # can be finalized for only one time
        if self.finalized or not self.is_valid(x): return
        self._x = x
        self.finalized = True


class Intervals:
    '''Collection of Interval instances.'''
    def __init__(self):
        self._instances = []

    def append(self, instance): self._instances.append(instance)
    

    def common_x(self):
        return set([instance.x for instance in self._instances])


    def solve(self):
        # collect interval points and sort in x-increasing order 
        x_points = set()
        for instance in self._instances:
            x_points.add(instance.LRange)
            x_points.add(instance.URange)
        
        x_points = list(x_points)
        x_points.sort()

        # check intersection status of each intervals
        x_status = []
        for i in range(len(x_points)-1):
            x = (x_points[i]+x_points[i+1])/2.0
            c = list(map(
                    lambda instance: int(instance.is_valid(x)), self._instances))
            x_status.append((x,c))
        
        # sort per count since preferring passing through more intervals
        x_status.sort(key=lambda item: sum(item[1]), reverse=True)

        # finalize instances
        num = len(self._instances)
        current_status = [0] * num
        for x, status in x_status:
            # terminate if all instances are finalized
            if sum(current_status) == num: break

            # only one line is allowed to pass through one interval -> sum(A.*B)=0
            #  e.g. A = [1,0,1,0], B=[0,1,0,0] -> valid
            #       A = [1,0,1,0], B =[1,0,0,0] -> invalid due to two lines passing through interval 1
            duplicated = sum([c1*c2 for c1,c2 in zip(current_status, status)])
            if duplicated: continue

            # update current status
            current_status = [c1+c2 for c1,c2 in zip(current_status, status)]

            # now, finalize instances
            for instance, instance_status in zip(self._instances, status):
                if instance_status: instance.finalize(x)



if __name__ == '__main__':
    

    inputs = [[8, 10], [2, 6], [4, 6], [1, 6], [4, 6], [5, 6]]

    I = Intervals()
    for x_range in inputs: I.append(Interval(x_range))

    I.solve()
    x = I.common_x()

    print(x)
```

